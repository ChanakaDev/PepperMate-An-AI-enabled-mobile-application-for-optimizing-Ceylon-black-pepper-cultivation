# -*- coding: utf-8 -*-
"""âœ… R-03 EfficientNet-B5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FbrOw9VnYTPgSarkydG3bDJULLCTfiPK
"""

# Importing essential packages
import os
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers, models, regularizers
from tensorflow.keras.callbacks import ReduceLROnPlateau
from tensorflow.keras.applications import EfficientNetB5

from google.colab import drive
drive.mount('/content/drive')

TRAIN_DIR = '/content/drive/MyDrive/pepper_mate_models/disease_classification_models/dataset/train'
VALIDATION_DIR = '/content/drive/MyDrive/pepper_mate_models/disease_classification_models/dataset/valid'
TEST_DIR = '/content/drive/MyDrive/pepper_mate_models/disease_classification_models/dataset/test'

def train_val_test_datasets():
    """Creates training, validation, and test datasets."""
    training_dataset = tf.keras.utils.image_dataset_from_directory(
        directory=TRAIN_DIR,
        batch_size=32,
        image_size=(640, 640),
        shuffle=True,
        seed=7,
        label_mode='categorical'
    )

    validation_dataset = tf.keras.utils.image_dataset_from_directory(
        directory=VALIDATION_DIR,
        batch_size=32,
        image_size=(640, 640),
        shuffle=True,
        seed=7,
        label_mode='categorical'
    )

    test_dataset = tf.keras.utils.image_dataset_from_directory(
        directory=TEST_DIR,
        batch_size=32,
        image_size=(640, 640),
        shuffle=True,
        seed=7,
        label_mode='categorical'
    )

    return training_dataset, validation_dataset, test_dataset

training_dataset, validation_dataset, test_dataset = train_val_test_datasets()

# Model creation function
def create_efficientnet_b5_model(input_shape=(640, 640, 3), num_classes=9):
    """Create an EfficientNet-B5 model for multi-class classification."""
    # Load EfficientNetB5 without the top layer
    base_model = EfficientNetB5(weights='imagenet', include_top=False, input_shape=input_shape)

    # Freeze the base model
    base_model.trainable = True

    # Create the model
    model = models.Sequential([
      base_model,
      layers.GlobalAveragePooling2D(),
      layers.Dense(512, activation='relu', kernel_regularizer=regularizers.l2(0.01)),
      layers.Dropout(0.5),
      layers.Dense(256, activation='relu', kernel_regularizer=regularizers.l2(0.01)),
      layers.Dropout(0.5),
      layers.Dense(num_classes, activation='softmax')
    ])

    return model

# Create the EfficientNet-B5 model
model = create_efficientnet_b5_model()

# Checking the model summary
model.summary()

from tensorflow.keras.callbacks import ReduceLROnPlateau

# Define ReduceLROnPlateau as a callback
reduce_lr = ReduceLROnPlateau(
    monitor='val_accuracy',
    factor=0.5,
    patience=3,
    min_lr=1e-6,
    verbose=1
)

# Define the cosine decay schedule
cosine_decay = tf.keras.optimizers.schedules.CosineDecay(
    initial_learning_rate=1e-3,
    decay_steps=1000,
    alpha=1e-6
)

# Use the cosine decay with the optimizer
optimizer = tf.keras.optimizers.Adam(learning_rate=cosine_decay)

# Compile the model
model.compile(
    optimizer=optimizer,
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

# Train the model with ReduceLROnPlateau as an additional callback
history = model.fit(
    training_dataset,
    validation_data=validation_dataset,
    epochs=15,
    callbacks=[reduce_lr]
)

# Evaluate the model on the test set
test_loss, test_accuracy = model.evaluate(test_dataset)
print(f"Test Loss: {test_loss}")
print(f"Test Accuracy: {test_accuracy}")

import matplotlib.pyplot as plt

# ... (Your previous code) ...

# Define epochs
epochs = range(1, len(history.history['accuracy']) + 1)

# Create subplots
fig, axes = plt.subplots(1, 2, figsize=(12, 5))  # 1 row, 2 columns

# Extract training and validation metrics from history
acc = history.history['accuracy']
val_acc = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']

# Training and validation accuracy
axes[0].plot(epochs, acc, 'b', label='Training Accuracy')
axes[0].plot(epochs, val_acc, 'r', label='Validation Accuracy')
axes[0].set_title('Training and Validation Accuracy')
axes[0].set_xlabel('Epochs')
axes[0].set_ylabel('Accuracy')
axes[0].legend()

# Training and validation loss
axes[1].plot(epochs, loss, 'b', label='Training Loss')
axes[1].plot(epochs, val_loss, 'r', label='Validation Loss')
axes[1].set_title('Training and Validation Loss')
axes[1].set_xlabel('Epochs')
axes[1].set_ylabel('Loss')
axes[1].legend()

# Adjust layout
plt.tight_layout()
plt.show()

model.save('/content/drive/MyDrive/pepper_mate_models/disease_classification_models/efficientnet_b5_model_r3.h5')